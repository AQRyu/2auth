# Copilot Instructions: HomeLabAuth (2auth)

## Project Context

OAuth2/OpenID Connect authentication service for home labs. Spring Boot + PostgreSQL + vanilla JS admin dashboard.

**Tech Stack:**

- Backend: Spring Boot 3.5.4, Java 21, PostgreSQL, JWT+TOTP 2FA
- Frontend: Bootstrap 5 + jQuery (no build process)
- Deploy: Docker Compose, multi-stage builds
- Dev: Spring DevTools, auto-start containers

## Key Architecture

```
├── backend/src/main/java/com/aqryuz/auth/
│   ├── controller/     # REST APIs: AdminController, AuthController, UserController
│   ├── service/        # Business logic: UserService, JwtService, TotpService
│   ├── entity/         # JPA: User (roles: USER/ADMIN)
│   ├── dto/           # Request/Response objects
│   ├── config/        # Security, CORS, OpenAPI
│   └── repository/    # Spring Data JPA
├── src/main/resources/static/
│   ├── index.html     # Admin dashboard UI
│   └── admin-dashboard.js  # All frontend logic
└── compose.yml        # Dev database (auto-start)
```

## Core Patterns

### Backend (Spring Boot)

- **Controllers**: `@RestController` with `/api/*` paths, DTOs, `@PreAuthorize("hasRole('ADMIN')")`
- **Services**: `@Service` + `@Transactional`, business logic separation
- **Security**: JWT (24h) + refresh tokens (7d), TOTP with QR codes
- **Entities**: `User` entity with roles Set<Role>, JPA relationships

### Frontend (Vanilla JS)

- **Structure**: jQuery + Bootstrap modals, no frameworks
- **Auth**: localStorage tokens, fetch() with Bearer headers
- **UI**: Form validation, loading states, error/success messages
- **Functions**: Grouped by feature (auth, user management, utilities)

### API Patterns

```javascript
// Standard auth request
await fetch(`${API_BASE}/api/auth/login`, {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({usernameOrEmail, password, totpCode})
});

// Authenticated requests
headers: {'Authorization': `Bearer ${authToken}`}
```

## Development Workflow

- **Start**: `./dev-start.sh` (auto-starts PostgreSQL via Spring Boot Docker Compose)
- **Frontend**: Edit `admin-dashboard.js` → refresh browser (immediate changes)
- **Backend**: Spring DevTools hot reload on Java changes
- **Testing**: JUnit 5 + Testcontainers for integration tests

## Common Tasks

**Add API endpoint:**

1. Create DTOs → Controller method → Service logic → Security annotations → Frontend integration

**Add user field:**

1. Update `User` entity → `UserInfo` DTO → Create/Update request DTOs → Frontend forms → Validation

**Add admin feature:**

1. `AdminController` + `@PreAuthorize("hasRole('ADMIN')")` → Service → Update `admin-dashboard.js`

## Key Dependencies

- `spring-boot-starter-oauth2-authorization-server` - OAuth2 support
- `io.jsonwebtoken:jjwt-*` - JWT handling
- `dev.samstevens.totp:totp` - 2FA implementation
- `spring-boot-docker-compose` - Auto-start containers
- `springdoc-openapi-starter-webmvc-ui` - API docs

## Security Notes

- JWT + refresh token flow, role-based access (`USER`/`ADMIN`)
- TOTP secrets encrypted in database
- Password policies, account lockout
- All admin operations require `ADMIN` role

**Philosophy**: Keep it simple and maintainable. No complex architectures.
